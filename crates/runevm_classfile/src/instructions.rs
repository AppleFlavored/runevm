use nom::{
    combinator::{map, success},
    number::complete::{be_u16, be_u8},
    IResult,
};

#[derive(Debug, Clone, Copy)]
pub enum Instruction {
    /// Represents an opcode that is not handled.
    Error(u8),

    Aaload,
    Aastore,
    AconstNull,
    Aload(u8),
    Anewarray(u16),
    Areturn,
    Arraylength,
    Astore(u8),
    Athrow,
    Baload,
    Bastore,
    Bipush(u8),
    Caload,
    Castore,
    Checkcast(u16),
    D2f,
    D2i,
    D2l,
    Dadd,
    Daload,
    Dastore,
    Dcmpg,
    Dcmpl,
    Dconst0,
    Dconst1,
    Ddiv,
    Dload(u8),
    Dmul,
    Dneg,
    Drem,
    Dreturn,
    Dstore,
    Dsub,
    Dup,
    DupX1,
    DupX2,
    Dup2,
    Dup2X1,
    Dup2X2,
    F2d,
    F2i,
    F2l,
    Fadd,
    Faload,
    Fastore,
    Fcmpg,
    Fcmpl,
    Fconst1,
    Fconst2,
    Fconst3,
    Fdiv,
    Fload(u8),
    Fmul,
    Fneg,
    Frem,
    Freturn,
    Fstore(u8),
    Fsub,
    Getfield(u16),
    Getstatic(u16),
    Goto(i16),
    Gotow(i32),
    I2b,
    I2c,
    I2d,
    I2f,
    I2l,
    I2s,
    Iadd,
    Iaload,
    Iand,
    Iastore,
    IconstM1,
    Iconst0,
    Iconst1,
    Iconst2,
    Iconst3,
    Iconst4,
    Iconst5,
    Idiv,
    Ifacmp(ComparisonKind, i16),
    Ificmp(ComparisonKind, i16),
    If(ComparisonKind, i16),
    Ifnonnull(i16),
    Ifnull(i16),
    Iinc(u8, i8),
    Iload(u8),
    Imul,
    Ineg,
    Instanceof(u16),
    Invokedynamic(u16),
    Invokeinterface(u16, u8),
    Invokespecial(u16),
    Invokestatic(u16),
    Invokevirtual(u16),
    Ior,
    Irem,
    Ireturn,
    Ishl,
    Ishr,
    Istore,
    Isub,
    Iushr,
    Ixor,
    Jsr(i16),
    Jsrw(i32),
    L2d,
    L2f,
    L2i,
    Ladd,
    Laload,
    Land,
    Lastore,
    Lcmp,
    Lconst0,
    Lconst1,
    Ldc(u8),
    Ldcw(u16),
    Ldc2w(u16),
    Ldiv,
    Lload(u8),
    Lmul,
    Lneg,
    Lookupswitch, // TODO: i aint doing allat
    Lor,
    Lrem,
    Lreturn,
    Lshl,
    Lshr,
    Lstore(u8),
    Lsub,
    Lushr,
    Lxor,
    Monitorenter,
    Monitorexit,
    Multianewarray(u16, u8),
    New(u16),
    Newarray(u8),
    Nop,
    Pop,
    Pop2,
    Putfield(u16),
    Putstatic(u16),
    Ret(u8),
    Return,
    Saload,
    Sastore,
    Sipush(u16),
    Swap,
    Tableswitch, // TODO: i aint doing allat pt.2
    Wide(u8, u16),
    Wide2(u16, u16),
}

#[derive(Debug, Clone, Copy)]
pub enum ComparisonKind {
    Eq,
    Ne,
    Lt,
    Ge,
    Gt,
    Le,
}

pub(crate) fn instruction(input: &[u8]) -> IResult<&[u8], Instruction> {
    let (input, opcode) = be_u8(input)?;
    match opcode {
        0x32 => zero_operands(Instruction::Aaload)(input),
        0x53 => zero_operands(Instruction::Aastore)(input),
        0x1 => zero_operands(Instruction::AconstNull)(input),
        0x19 => map(be_u8, |index| Instruction::Aload(index))(input),
        0x2a..=0x2d => zero_operands(Instruction::Aload(opcode - 42))(input),
        0xb1 => zero_operands(Instruction::Return)(input),
        0xb2 => map(be_u16, |index| Instruction::Getstatic(index))(input),
        0x12 => map(be_u8, |index| Instruction::Ldc(index))(input),
        0xb6 => map(be_u16, |index| Instruction::Invokevirtual(index))(input),
        0xb7 => map(be_u16, |index| Instruction::Invokespecial(index))(input),
        _ => success(Instruction::Error(opcode))(input),
    }
}

fn zero_operands(instruction: Instruction) -> impl Fn(&[u8]) -> IResult<&[u8], Instruction> {
    move |input| success(instruction)(input)
}
